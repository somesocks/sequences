# sequences

## About

`sequences` is a collection of utilities for working with lazily-evaluated
sequences of data.

Working with lazily-evaluated sequences can be more efficient than other JS alternatives, as it allows you to minimize intermediate
memory allocations where possible, and only perform operations on elements that contribute to your final result.

```javascript

// temporary arrays are created by filter and map,
let val = [-3, -2, -1, 0, 1, 2, 3]
	.filter((val) => val > 0)
	.map((val) => val + 1)
	.reduce((sum, val) => sum + val, 0);

// no temporary arrays
let val2 = FromArray([-3, -2, -1, 0, 1, 2, 3])
	.pipe(Filter, (val) => val > 0)
	.pipe(Map, (val) => val + 1)
	.pipe(Reduce, (sum, val) => sum + val, 0)
	.read();

```


## Why not ES6 Iterators?

- ES6 Iterators require a temporary `{ done, value }` object to be allocated with every call, which reduces performace.

- `Sequence().read()` accepts a 'recycle' parameter when called, which allows you to re-use previously allocated values, to minimize allocations.

- `Sequence().read()` returns the next result or the terminator `Sequence().END`, which can simplify control flow compared to having an "independent" control channel (the iterator `done` parameter).

## Why ES6 Iterators?

- You want to use the Iterable protocol.


## API

{{> main}}
